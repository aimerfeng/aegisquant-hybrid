//! Strategy module for trading signal generation.
//!
//! Provides the Strategy trait and implementations including
//! the Dual Moving Average (DualMA) crossover strategy.

use crate::types::{OrderRequest, StrategyParams, Tick, DIRECTION_BUY, DIRECTION_SELL, ORDER_TYPE_MARKET};

/// Trading signal generated by a strategy.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Signal {
    /// No action
    None,
    /// Buy signal
    Buy,
    /// Sell signal
    Sell,
}

/// Strategy trait for generating trading signals.
pub trait Strategy: Send + Sync {
    /// Process a new tick and potentially generate a signal.
    ///
    /// # Arguments
    /// * `tick` - The new market data tick
    ///
    /// # Returns
    /// A trading signal (None, Buy, or Sell)
    fn on_tick(&mut self, tick: &Tick) -> Signal;

    /// Generate an order request from a signal.
    ///
    /// # Arguments
    /// * `signal` - The trading signal
    /// * `symbol` - The trading symbol
    /// * `price` - Current market price
    ///
    /// # Returns
    /// An optional OrderRequest if the signal requires action
    fn generate_order(&self, signal: Signal, symbol: &str, price: f64) -> Option<OrderRequest>;

    /// Reset the strategy state.
    fn reset(&mut self);

    /// Get the strategy name.
    fn name(&self) -> &str;
}

/// Dual Moving Average crossover strategy.
///
/// Generates buy signals when short MA crosses above long MA (golden cross),
/// and sell signals when short MA crosses below long MA (death cross).
#[derive(Debug)]
pub struct DualMAStrategy {
    /// Strategy parameters
    params: StrategyParams,
    /// Price buffer for MA calculation (pre-allocated)
    price_buffer: Vec<f64>,
    /// Current position in the circular buffer
    buffer_pos: usize,
    /// Number of prices received
    price_count: usize,
    /// Previous short MA value
    prev_short_ma: Option<f64>,
    /// Previous long MA value
    prev_long_ma: Option<f64>,
    /// Current position direction (1 = long, -1 = short, 0 = flat)
    current_position: i32,
}

impl DualMAStrategy {
    /// Create a new DualMAStrategy with the given parameters.
    pub fn new(params: StrategyParams) -> Self {
        let buffer_size = params.long_ma_period.max(params.short_ma_period) as usize;
        Self {
            params,
            price_buffer: vec![0.0; buffer_size],
            buffer_pos: 0,
            price_count: 0,
            prev_short_ma: None,
            prev_long_ma: None,
            current_position: 0,
        }
    }

    /// Calculate simple moving average over the last n prices.
    fn calculate_ma(&self, period: usize) -> Option<f64> {
        if self.price_count < period {
            return None;
        }

        let buffer_size = self.price_buffer.len();
        let mut sum = 0.0;

        for i in 0..period {
            let idx = (self.buffer_pos + buffer_size - 1 - i) % buffer_size;
            sum += self.price_buffer[idx];
        }

        Some(sum / period as f64)
    }

    /// Get the short MA period.
    pub fn short_ma_period(&self) -> i32 {
        self.params.short_ma_period
    }

    /// Get the long MA period.
    pub fn long_ma_period(&self) -> i32 {
        self.params.long_ma_period
    }

    /// Get the current short MA value.
    pub fn current_short_ma(&self) -> Option<f64> {
        self.calculate_ma(self.params.short_ma_period as usize)
    }

    /// Get the current long MA value.
    pub fn current_long_ma(&self) -> Option<f64> {
        self.calculate_ma(self.params.long_ma_period as usize)
    }

    /// Get the previous short MA value.
    pub fn prev_short_ma(&self) -> Option<f64> {
        self.prev_short_ma
    }

    /// Get the previous long MA value.
    pub fn prev_long_ma(&self) -> Option<f64> {
        self.prev_long_ma
    }

    /// Get the current position direction.
    pub fn current_position(&self) -> i32 {
        self.current_position
    }

    /// Get the number of prices received.
    pub fn price_count(&self) -> usize {
        self.price_count
    }
}

impl Default for DualMAStrategy {
    fn default() -> Self {
        Self::new(StrategyParams::default())
    }
}

impl Strategy for DualMAStrategy {
    fn on_tick(&mut self, tick: &Tick) -> Signal {
        // Add price to buffer
        self.price_buffer[self.buffer_pos] = tick.price;
        self.buffer_pos = (self.buffer_pos + 1) % self.price_buffer.len();
        self.price_count += 1;

        // Calculate current MAs
        let short_ma = match self.calculate_ma(self.params.short_ma_period as usize) {
            Some(ma) => ma,
            None => return Signal::None, // Not enough data
        };

        let long_ma = match self.calculate_ma(self.params.long_ma_period as usize) {
            Some(ma) => ma,
            None => return Signal::None, // Not enough data
        };

        // Detect crossover
        let signal = match (self.prev_short_ma, self.prev_long_ma) {
            (Some(prev_short), Some(prev_long)) => {
                // Golden cross: short MA crosses above long MA
                if prev_short <= prev_long && short_ma > long_ma {
                    Signal::Buy
                }
                // Death cross: short MA crosses below long MA
                else if prev_short >= prev_long && short_ma < long_ma {
                    Signal::Sell
                } else {
                    Signal::None
                }
            }
            _ => Signal::None, // First tick with both MAs
        };

        // Update previous values
        self.prev_short_ma = Some(short_ma);
        self.prev_long_ma = Some(long_ma);

        // Update position based on signal
        match signal {
            Signal::Buy => self.current_position = 1,
            Signal::Sell => self.current_position = -1,
            Signal::None => {}
        }

        signal
    }

    fn generate_order(&self, signal: Signal, symbol: &str, price: f64) -> Option<OrderRequest> {
        match signal {
            Signal::None => None,
            Signal::Buy => {
                let mut order = OrderRequest::with_symbol(symbol);
                order.quantity = self.params.position_size;
                order.direction = DIRECTION_BUY;
                order.order_type = ORDER_TYPE_MARKET;
                order.limit_price = price;
                Some(order)
            }
            Signal::Sell => {
                let mut order = OrderRequest::with_symbol(symbol);
                order.quantity = self.params.position_size;
                order.direction = DIRECTION_SELL;
                order.order_type = ORDER_TYPE_MARKET;
                order.limit_price = price;
                Some(order)
            }
        }
    }

    fn reset(&mut self) {
        self.price_buffer.fill(0.0);
        self.buffer_pos = 0;
        self.price_count = 0;
        self.prev_short_ma = None;
        self.prev_long_ma = None;
        self.current_position = 0;
    }

    fn name(&self) -> &str {
        "DualMA"
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_tick(price: f64) -> Tick {
        Tick {
            timestamp: 0,
            price,
            volume: 1000.0,
        }
    }

    #[test]
    fn test_strategy_creation() {
        let params = StrategyParams {
            short_ma_period: 5,
            long_ma_period: 10,
            position_size: 100.0,
            stop_loss_pct: 0.02,
            take_profit_pct: 0.05,
        };
        let strategy = DualMAStrategy::new(params);
        assert_eq!(strategy.short_ma_period(), 5);
        assert_eq!(strategy.long_ma_period(), 10);
    }

    #[test]
    fn test_no_signal_insufficient_data() {
        let params = StrategyParams {
            short_ma_period: 3,
            long_ma_period: 5,
            ..Default::default()
        };
        let mut strategy = DualMAStrategy::new(params);

        // Not enough data for long MA
        for i in 0..4 {
            let signal = strategy.on_tick(&create_tick(100.0 + i as f64));
            assert_eq!(signal, Signal::None);
        }
    }

    #[test]
    fn test_golden_cross_buy_signal() {
        let params = StrategyParams {
            short_ma_period: 2,
            long_ma_period: 3,
            position_size: 100.0,
            ..Default::default()
        };
        let mut strategy = DualMAStrategy::new(params);

        // Build up data: prices going down then up
        // This should create a golden cross
        let prices = vec![100.0, 95.0, 90.0, 95.0, 100.0, 110.0];
        let mut signals = Vec::new();

        for price in prices {
            let signal = strategy.on_tick(&create_tick(price));
            signals.push(signal);
        }

        // Should have at least one buy signal
        assert!(signals.contains(&Signal::Buy), "Should have a buy signal on golden cross");
    }

    #[test]
    fn test_death_cross_sell_signal() {
        let params = StrategyParams {
            short_ma_period: 2,
            long_ma_period: 3,
            position_size: 100.0,
            ..Default::default()
        };
        let mut strategy = DualMAStrategy::new(params);

        // Build up data: prices going up then down
        // This should create a death cross
        let prices = vec![100.0, 105.0, 110.0, 105.0, 100.0, 90.0];
        let mut signals = Vec::new();

        for price in prices {
            let signal = strategy.on_tick(&create_tick(price));
            signals.push(signal);
        }

        // Should have at least one sell signal
        assert!(signals.contains(&Signal::Sell), "Should have a sell signal on death cross");
    }

    #[test]
    fn test_generate_buy_order() {
        let params = StrategyParams {
            position_size: 100.0,
            ..Default::default()
        };
        let strategy = DualMAStrategy::new(params);

        let order = strategy.generate_order(Signal::Buy, "BTCUSDT", 50000.0);
        assert!(order.is_some());

        let order = order.unwrap();
        assert_eq!(order.symbol_str(), "BTCUSDT");
        assert_eq!(order.quantity, 100.0);
        assert_eq!(order.direction, DIRECTION_BUY);
    }

    #[test]
    fn test_generate_sell_order() {
        let params = StrategyParams {
            position_size: 50.0,
            ..Default::default()
        };
        let strategy = DualMAStrategy::new(params);

        let order = strategy.generate_order(Signal::Sell, "ETHUSDT", 3000.0);
        assert!(order.is_some());

        let order = order.unwrap();
        assert_eq!(order.symbol_str(), "ETHUSDT");
        assert_eq!(order.quantity, 50.0);
        assert_eq!(order.direction, DIRECTION_SELL);
    }

    #[test]
    fn test_no_order_for_none_signal() {
        let strategy = DualMAStrategy::default();
        let order = strategy.generate_order(Signal::None, "BTCUSDT", 50000.0);
        assert!(order.is_none());
    }

    #[test]
    fn test_reset() {
        let mut strategy = DualMAStrategy::default();

        // Add some data
        for i in 0..10 {
            strategy.on_tick(&create_tick(100.0 + i as f64));
        }

        assert!(strategy.price_count() > 0);

        // Reset
        strategy.reset();

        assert_eq!(strategy.price_count(), 0);
        assert!(strategy.prev_short_ma().is_none());
        assert!(strategy.prev_long_ma().is_none());
    }

    #[test]
    fn test_ma_calculation() {
        let params = StrategyParams {
            short_ma_period: 3,
            long_ma_period: 5,
            ..Default::default()
        };
        let mut strategy = DualMAStrategy::new(params);

        // Add 5 prices: 100, 102, 104, 106, 108
        for i in 0..5 {
            strategy.on_tick(&create_tick(100.0 + (i * 2) as f64));
        }

        // Short MA (last 3): (104 + 106 + 108) / 3 = 106
        let short_ma = strategy.current_short_ma().unwrap();
        assert!((short_ma - 106.0).abs() < 0.001);

        // Long MA (last 5): (100 + 102 + 104 + 106 + 108) / 5 = 104
        let long_ma = strategy.current_long_ma().unwrap();
        assert!((long_ma - 104.0).abs() < 0.001);
    }
}
